<?xml version="1.0"?>
<doc>
  <assembly>
    <name>BertecKinamotoRuntime</name>
  </assembly>
  <members>
    <member name="T:Bertec.ExecuteOnMainThread">
      <summary>
            This is a static class that provides a handy functionality to resolve the gap with processing functions from one thread into the
            other. By using ExecuteOnMainThread.AddAction with the function in question and having your main loop code call 
            ExecuteOnMainThread.ProcessActions it will "stack" the function calls until the main thread dequeues them.
            This is useful when processing incoming TCP or WebSocket data and needing to use a function that would manipulate a GUI or 3d object.
            </summary>
    </member>
    <member name="M:Bertec.ExecuteOnMainThread.AddAction(System.Action)">
      <summary>
            Adds the passed Action object to the queue to execute later on the main thread.
            Make sure your main Update() loop calls ExecuteOnMainThread.ProcessActions()
            </summary>
      <param name="act">The action to perform. Ex: () =&gt; { CommandAddObject(connectionID, keyValuePairs); }</param>
    </member>
    <member name="M:Bertec.ExecuteOnMainThread.ClearActions">
      <summary>
            Removes all pending queue actions from the main thread execute queue.
            </summary>
    </member>
    <member name="T:Bertec.KeyPointVisualizerEvents.VisualizerMode">
      <summary>
            The mode that the scene is expected to be in. This depends on both the Bertec.SceneFeatures.Keypoints setting and the
            UI selection.
            </summary>
    </member>
    <member name="F:Bertec.KeyPointVisualizerEvents.VisualizerMode.None">
      <summary>
            No visualizer mode selected. Not commonly triggered or handled.
            </summary>
    </member>
    <member name="F:Bertec.KeyPointVisualizerEvents.VisualizerMode.FirstPerson">
      <summary>
            Only available if Bertec.SceneFeatures.KeypointOptions.KeypointsAllowed is set. Mode when the user selects First Person.
            <remarks>You scene will get KeypointUpdated with new values and ids</remarks></summary>
    </member>
    <member name="F:Bertec.KeyPointVisualizerEvents.VisualizerMode.ThirdPerson">
      <summary>
            Only available if Bertec.SceneFeatures.KeypointOptions.KeypointsAllowed is set. Mode when the user selects Third Person
            <remarks>You scene will get KeypointUpdated with new values and ids</remarks></summary>
    </member>
    <member name="F:Bertec.KeyPointVisualizerEvents.VisualizerMode.CoP">
      <summary>
            Only available if Bertec.SceneFeatures.KeypointOptions.CoPAllowed is set.
            <remarks>You scene will get CoPVisualizerUpdated with the selected visualizer object, if any</remarks></summary>
    </member>
    <member name="E:Bertec.KeyPointVisualizerEvents.VisualizerModeChanged">
      <summary>
            Invoked when the UI changes the Visualizer type, if any
            </summary>
    </member>
    <member name="E:Bertec.KeyPointVisualizerEvents.VisualizerChanged">
      <summary>
            Invoked when the UI changes a visualizer selection. The new string will the be key name that the scene should handle.
            For the COP, you should compare the key against the FORCEPLATEKEYPOINTTAG static string.
            </summary>
    </member>
    <member name="E:Bertec.KeyPointVisualizerEvents.KeypointPositionUpdated">
      <summary>
            Invoked when the keypoint visualizer data is updated. Your scene should move the keypoint id to the passed vector.
            For the COP, you should compare the key against the FORCEPLATEKEYPOINTTAG static string.
            </summary>
    </member>
    <member name="E:Bertec.ObstacleEvents.OnResetHitMissCounts">
      <summary>Invoked when the PC side wants the Scene to reset the hit/miss counts for the Obstacle. Typically when starting/restarting a protocol</summary>
    </member>
    <member name="M:Bertec.ObstacleEvents.ObstacleDisplayed">
      <summary>Call this when an Obstacle shows up on the screen; the PC side may elect to trigger an event with this</summary>
    </member>
    <member name="M:Bertec.ObstacleEvents.ObstacleHidden">
      <summary>Call this when an Obstacle is removed from the screen; the PC side may elect to trigger an event with this</summary>
    </member>
    <member name="M:Bertec.ObstacleEvents.UpdateHitMiss(System.Int32,System.Int32)">
      <summary>Call to update the running hit/miss count for Obstacles. The PC side will keep track of this and display info and recording</summary>
    </member>
    <member name="F:Bertec.PassThroughViewContainer.Scene">
      <summary>
            The main scene to hide when the passthrough is turned on; if null, then both the passthrough and scene are visible.
            </summary>
      <remarks>If not set, the Framework will automatically use the gameobject named "MainScene", if any.</remarks>
    </member>
    <member name="F:Bertec.PassThroughViewContainer.XRRigMainCamera">
      <summary>
            The headset eye camera; this is not the same as the 'other' main camera or the external camera hardware.
            </summary>
      <remarks>If not set, the Framework will automatically find the camera object. Required so that passthrough works correctly.</remarks>
    </member>
    <member name="F:Bertec.PassThroughViewContainer.AllowControlerButtonBypass">
      <summary>
            Determines whether the controller button bypass is allowed. Only set this if your scene requires all buttons.
            </summary>
    </member>
    <member name="M:Bertec.PassThroughViewContainer.FindXRRigMainCamera">
      <summary>
            Finds the main XR camera; called when the XRRigMainCamera property is not set.
            </summary>
      <returns>The XRRig main camera.</returns>
    </member>
    <member name="M:Bertec.PassThroughViewContainer.EnableHeadsetPassthrough(System.Boolean)">
      <summary>
            Turns on the realtime camera and uses it as the environmental background.
            </summary>
    </member>
    <member name="M:Bertec.PassThroughViewContainer.CameraColorsChanged">
      <summary>
            This should be called if you change the main Skybox or camera background colors at runtime.
            Failing to do so will cause returning from passthrough mode to render incorrectly.
            </summary>
    </member>
    <member name="T:Bertec.FrameworkInitAttribute">
      <summary>
            This attribute extends the Unity.RuntimeInitializeOnLoadMethod attribute to allow more finer-grained control from within our
            own framework. The init levels allow both before and after each stage, so you can be sure to have things initialized in more or
            less the proper order.
            A further level of control might be possible with a "priority level" int value, to order each init within its own scope.
            </summary>
    </member>
    <member name="M:Bertec.ProtocolFramework.Terminate(System.Boolean)">
      <summary>
            Call all the shutdown methods and disconnect the RPC, then exit the application. This will do a hard-kill of the running app,
            not just send it to the back and suspend it. Use instead of UnityEngine.Application.Quit()
            </summary>
    </member>
    <member name="T:Bertec.StartupTypeAttribute">
      <summary>
            This attribute is used by the Framework to flag that the Unity Project is classic or server scene; by default, it will be
            "client" scene so the Kinamoto Customer scenes don't need to do any extra work.
            </summary>
    </member>
    <member name="E:Bertec.OptionChangedContainer_Impl.OnOptionChanged">
      <summary>
            This event is triggered when an option is changed.
            </summary>
    </member>
    <member name="M:Bertec.OptionChangedContainer_Impl.OptionChanged(System.String,System.Object)">
      <summary>
            Advanced function to allow derived classes to override the option changed event if you derive from OptionChangedContainer
            instead of using it as a prefab game object. Typically not needed.
            </summary>
      <param name="optionName">The name of the option.</param>
      <param name="optionValue">The new value of the option.</param>
    </member>
    <member name="M:Bertec.OptionChangedContainer_Impl.Connect(System.Action{System.String,System.Object})">
      <summary>
            Connects the specified action to the OnOptionChanged event.
            </summary>
      <param name="onoptionchanged">The action to be connected to the event.</param>
    </member>
    <member name="M:Bertec.OptionChangedContainer_Impl.Disconnect(System.Action{System.String,System.Object})">
      <summary>
            Disconnects the specified action from the OnOptionChanged event. Typically not needed since the class manages it.
            </summary>
      <param name="onoptionchanged">The action to be disconnected from the event.</param>
    </member>
    <member name="P:Bertec.OptionChangedContainer_Impl.OptionEvents">
      <summary>
            Gets the ProtocolOptionChangedEventHandler instance.
            </summary>
    </member>
    <member name="T:Bertec.ProtocolOptions">
      <summary>
            This class connects to the protocol-command web socket interface and allows you to issue commands over that.
            Some protocols support the ProtocolCommand interface, allowing for commands to be sent to them. These commands
            can be simple things (ex: SetScore) with no response or more complex functions that return a single future result
            (ex: GetScoreForAgeGroup). Other commands return *periodic* updates, similar to the COPDataReader and friends.
            These periodic updates can be considered either event signals (ex: some condition has changed) or continual
            data updates (ex: live calculations against the data flow)
            </summary>
      <note>This is basically a convenience wrapper around the ProtocolRPC functions.</note>
      <note>Like ProtocolRPC, all the public functions are static.</note>
    </member>
    <member name="M:Bertec.ProtocolOptions.StringValue(System.String)">
      <summary>
            Get the string value for the given command line parm; if it doesn't exist, an empty string is returned.
            Note that if there are multiple values for this key (ex: -foo 1 -foo 2) then the results are a comma separated string (1,2).
            </summary>
      <param name="key">The command line parm</param>
      <returns>The value of the key</returns>
    </member>
    <member name="M:Bertec.ProtocolOptions.StringValue(System.String,System.String)">
      <summary>
            Get the string value for the given command line parm; if it doesn't exist, the default val string is returned.
            Note that if there are multiple values for this key (ex: -foo 1 -foo 2) then the results are a comma separated string (1,2).
            </summary>
      <param name="key">The command line parm</param>
      <param name="val">Default value if key does not exist</param>
      <returns>The value of the key</returns>
    </member>
    <member name="M:Bertec.ProtocolOptions.IntValue(System.String,System.Int32)">
      <summary>
            Get the intiger value for the given command line parm; if it doesn't exist, the default val is returned.
            Note that if there are multiple values for this key (ex: -foo 1 -foo 2) then the results are undefined.
            </summary>
      <param name="key">The command line parm</param>
      <param name="val">Default value if key does not exist</param>
      <returns>The intiger value of the key</returns>
    </member>
    <member name="M:Bertec.ProtocolOptions.Unsigned64Value(System.String,System.UInt64)">
      <summary>
            Get the unsigned 64 bit intiger value for the given command line parm; if it doesn't exist, the default val is returned.
            Note that if there are multiple values for this key (ex: -foo 1 -foo 2) then the results are undefined.
            </summary>
      <param name="key">The command line parm</param>
      <param name="val">Default value if key does not exist</param>
      <returns>The intiger value of the key</returns>
    </member>
    <member name="M:Bertec.ProtocolOptions.FloatValue(System.String,System.Single)">
      <summary>
            Get the float value for the given command line parm; if it doesn't exist, the default val is returned.
            Note that if there are multiple values for this key (ex: -foo 1 -foo 2) then the results are undefined.
            </summary>
      <param name="key">The command line parm</param>
      <param name="val">Default value if key does not exist</param>
      <returns>The float value of the key</returns>
    </member>
    <member name="M:Bertec.ProtocolOptions.BoolValue(System.String,System.Boolean)">
      <summary>
            Get the boolean value for the given command line parm; if it doesn't exist, the default val is returned.
            This function handles both numbers (0,1,-1) and strings (false, true). 0 is treated as false, anything else is treated as true.
            Note that if there are multiple values for this key (ex: -foo 0 -foo 1) then the results are undefined.
            </summary>
      <param name="key">The command line parm</param>
      <param name="val">Default boolean value if key does not exist</param>
      <returns>The value of the key</returns>
    </member>
    <member name="M:Bertec.ProtocolOptions.ColorValue(System.String,UnityEngine.Color)">
      <summary>
            Get the given command line parm as a Unity Color object. This method handles both discrete numbers (1,2,3)
            and HTML-style hex colors (#010203). Both RGB and RGBA variants are supported.
            Note that if there are multiple values for this key (ex: -foo 1 -foo 2) then the results are undefined.
            </summary>
      <param name="key">The command line parm</param>
      <param name="val">Default color value if key does not exist</param>
      <returns>A Color object</returns>
    </member>
    <member name="M:Bertec.ProtocolOptions.Vector2Value(System.String,UnityEngine.Vector2)">
      <summary>
            Get the given command line parm as a Unity Vector2 object, that is, two discrete numbers (1.0,2.5)
            Note that if there are multiple values for this key (ex: -foo 1 -foo 2) then the results are undefined.
            </summary>
      <param name="key">The command line parm</param>
      <param name="val">Default Vector2 value if key does not exist</param>
      <returns>A Vector2 object</returns>
    </member>
    <member name="M:Bertec.ProtocolOptions.Vector3Value(System.String,UnityEngine.Vector3)">
      <summary>
            Get the given command line parm as a Unity Vector3 object, that is, three discrete numbers (1.0,2.5,3.9)
            Note that if there are multiple values for this key (ex: -foo 1 -foo 2) then the results are undefined.
            </summary>
      <param name="key">The command line parm</param>
      <param name="val">Default Vector3 value if key does not exist</param>
      <returns>A Vector3 object</returns>
    </member>
    <member name="T:Bertec.ProtocolRPC">
      <summary>
            Class that manages the websocket connection and the rpc commands. Does the command dispatch (callbacks) for the registered handles and etc.
            </summary>
    </member>
    <member name="P:Bertec.ProtocolRPC.IsConnected">
      <summary>
            Returns TRUE if the web socket interface is currently connected. This does not mean that communication is actually taking
            place but just that a server of some type exists on the other end.
            </summary>
    </member>
    <member name="M:Bertec.ProtocolRPC.IssueResponse(System.UInt64,System.Object)">
      <summary>
            Sends the response from the handled command object and parms over in a fire-and-forget manner; no callbacks are set up to be handled and there is no return value. 
            </summary>
      <param name="responseID">The response uuid that will be sent back; the other side will handle this.</param>
      <param name="parms">An object (typically an anonmyous type) of parms to be sent. These will be converted to a JSON object string.</param>
      <returns>No return value</returns>
      <note>IssueResponse is the same as IssueCommand and calls that if responseID is non zero</note>
    </member>
    <member name="M:Bertec.ProtocolRPC.IssueCommand(System.UInt64,System.Object)">
      <summary>
            Sends the command and the parms over in a fire-and-forget manner; no callbacks are set up to be handled and there is no return value. 
            </summary>
      <param name="cmdID">The command to be sent to the web socket interface; these are currently defined on the server.</param>
      <param name="parms">An object (typically an anonmyous type) of parms to be sent. These will be converted to a JSON object string.</param>
      <returns>No return value</returns>
    </member>
    <member name="M:Bertec.ProtocolRPC.IssueCommand(System.UInt64,System.Object,System.Action{Bertec.CoreWebSocketCommandPacket})">
      <summary>
            Sends the command and the parms with a callback id that will invoke the completionCallback method if and when the host returns a value.
            This is expected to result in a single updates which will call the completionCallback once and then remove the uuid and callback from the internal table.
            </summary>
      <param name="cmdID">The command to be sent to the web socket interface; these are currently defined on the server.</param>
      <param name="parms">An object (typically an anonmyous type) of parms to be sent. These will be converted to a JSON object string.</param>
      <param name="completionCallback">The method that should be invoked when the server returns back a result. The method will be called
            with the raw JSON string and an generic object parsed from the JSON string.</param>
      <returns>The UUID that was assigned to this command. Can be used for internal bookkeeping or for later use by RemoveCallback.</returns>
    </member>
    <member name="M:Bertec.ProtocolRPC.IssueProtocolCommand(System.String,System.Object)">
      <summary>
            Issues a protocol command under the PROTOCOLCOMMAND command id with parms and no completion callback. The main desktop
            protocol handler will respond to whatever this is. This is specific to the protocol itself and may not be compatible between
            different protocols
            </summary>
      <param name="command">the protocol-specific command to issue. Sent as-is</param>
      <param name="parms">anonymous collection parms for the command</param>
    </member>
    <member name="M:Bertec.ProtocolRPC.AddCommandHandler(System.UInt64,System.Action{Bertec.CoreWebSocketCommandPacket})">
      <summary>
            Adds a callback handler for the given command command id.
            </summary>
      <param name="cmdID">The command id that should be matched.</param>
      <param name="completionCallback">The method that should be invoked when the websocket recieves the command id.
            The method will be called with the CoreWebSocketCommandPacket which can be used to unpack the data and optionally send back a response.</param>
    </member>
    <member name="M:Bertec.ProtocolRPC.RemoveCommandHandler(System.UInt64)">
      <summary>
            Removes the callback for the given command id. This does *NOT* tell the server to stop sending results for the command; it just stops
            responding to that command. If you need the server to stop sending data, you should send whatever matching "stop" command is available
            for the previous command, if applicable.
            </summary>
      <param name="cmdID">The command id that was passed into AddCommandHandler</param>
    </member>
    <member name="T:Bertec.ProtocolRPCBridge">
      <summary>
            Websocket server class that handles accepting connections from sub-packages and forwarding them to the pc
            <note>Unlike ProtocolRPC, this is not a singleton and is a member variable of ProtocolRPC</note>
            There are also some other considerations that need to be made. First, what happens when the main RPC connection is lost?
            Right now we close the connection for all the other running apk's, which may not be what we want or need.
            Second, the way things are set up in the PC is that the video stream is only started on the initial connect to the main
            Bridge, so if the apk starts later (which wil be 100% of the time), then it never gets the stream start command. So we need
            to have the PC side issue the video start probably at the point of scene switch, not on connect.
            We will also need to be able to issue back to the PC that the apk is closing, so that the PC can close the video stream.
            The apk 'client' connection open/close events need to trigger messages back to the pc.
            </summary>
    </member>
    <member name="T:Bertec.SceneInfoAttribute">
      <summary>
            Attribute tag class that is used by the build step to generate a json file of all the scene info that Kinamoto can then read
            </summary>
    </member>
    <member name="F:Bertec.SceneChoiceItem.Key">
      <summary>
            Required. The unique id within this option that will be used to track the selected option choice (can be same in different options, does not need to be globally unique).
            <note type="important">
            The Key is used to track the value, so it must be unique within the option. The Name is what is displayed to the user.
            Typically, the choice's 'value' is the same as the key - so for example, if you have a Key equal to '8', the value would be 8.
            Key can be a string like 'blue' or a number like '2.5'. The scene handler is expected to understand what to do with it.
            </note></summary>
    </member>
    <member name="F:Bertec.SceneChoiceItem.Name">
      <summary>
            Optional. The display name that is shown on the UI display.
            </summary>
    </member>
    <member name="F:Bertec.SceneChoiceItem.Description">
      <summary>
            Optional. Describes what the event is (can be used for the UI or other documentation).
            </summary>
    </member>
    <member name="M:Bertec.SceneChoiceItem.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Bertec.SceneChoiceItem" /> class.
            </summary>
    </member>
    <member name="M:Bertec.SceneChoiceItem.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Bertec.SceneChoiceItem" /> class.
            </summary>
      <param name="v">The value to be used for the Key and Name.</param>
    </member>
    <member name="M:Bertec.SceneChoiceItem.#ctor(System.Object,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Bertec.SceneChoiceItem" /> class.
            </summary>
      <param name="k">The value to be used for the Key.</param>
      <param name="n">The value to be used for the Name.</param>
    </member>
    <member name="F:Bertec.SceneChoices.Items">
      <summary>
            Array of choices that will be displayed for the user to see.
            Choices will be shown in the same order as they appear in the array.
            Not used for the Title type.
            </summary>
    </member>
    <member name="F:Bertec.SceneChoices.DefaultChoice">
      <summary>
            Optional. If the item's value has not been set by other means (such as reloading a previous test), then the default
            value will be set using this from this. Depending on the item, this can be a value from the list of choices (type = panel),
            the word checked or unchecked (type = checkbox), a string (type = edit) or a date string (type = date).
            Not used for the Title type.
            </summary>
    </member>
    <member name="F:Bertec.CognitiveChoiceItem.SubOptions">
      <summary>
            Optional. Possible sub options that can be selected for the Cognitive choice.
            If not set/defined/only one, then the UI will not show a sub-option panel.
            </summary>
    </member>
    <member name="F:Bertec.CognitiveChoiceItem.SubOptionName">
      <summary>
            Required if SubOptions is defined. What is shown in the UI as the label lead-in for the SubOptions
            </summary>
    </member>
    <member name="F:Bertec.CognitiveChoices.Items">
      <summary>
            Array of Cognitive choices that will be displayed for the user to see.
            Items will be shown in the same order as they appear in the array.
            </summary>
    </member>
    <member name="T:Bertec.SceneFeatures">
      <summary>
            SceneFeatures are separate from the Scene Options and are used to drive more specific effects that have broad applicable terms,
            and more rich UI interfaces than standard options. Some of the capabilities are handled fully by the Framework (ex: PostProcessing, Rotation),
            but others will require your scene handle event triggers and values.
            </summary>
    </member>
    <member name="F:Bertec.SceneFeatures.VisualFlow">
      <summary>
            Implies the scene moves with the treadmill. The UI will provide a belt sync checkbox, fixed scene velocity value, and belt speed multiplier.
            </summary>
    </member>
    <member name="F:Bertec.SceneFeatures.HasPostProcessing">
      <summary>
            Implies Vignette, Grain, and possibility other effects in the UI. The framework will handle these features.
            </summary>
    </member>
    <member name="F:Bertec.SceneFeatures.HasObstacles">
      <summary>
            Implies the protocol will either trigger or respond to obstacles in the scene, and expects to be notified if hit/miss.
            <remarks>How the obstacles are presented and controlled is up to the scene, including any options to turn them on/off.</remarks><remarks>Turning this on means you intend to use the ObstacleEvents class.</remarks></summary>
    </member>
    <member name="F:Bertec.SceneFeatures.HasCameraPosition">
      <summary>
            Implies position x/y/z inputs and controls in the UI. The framework will handle the positioning.
            </summary>
    </member>
    <member name="F:Bertec.SceneFeatures.CameraRotation">
      <summary>
            Implies rotation x/y/z inputs and controls in the UI. The framework will handle the rotation.
            </summary>
    </member>
    <member name="F:Bertec.SceneFeatures.CoPKeypointVisualizers">
      <summary>
            If CoPVisualizer or KeypointVisualizer set, has a special Key Point Visualizer panel in the UI that fills in from the rest of the options.
            These are tied into the Bertec.KeyPointVisualizerEvents class and the Bertec.KeyPointVisualizerEvents.VisualizerMode enum
            </summary>
      <summary>
            If set, then the Key Point Visualizer UI will have the COP Visualizer option available, and your code should respond to the COP data.
            See Bertec.KeyPointVisualizerEvents.CoPVisualizerChanged for handle switching the cop keypoint type.
            </summary>
    </member>
    <member name="F:Bertec.SceneFeatures.KeypointVisualizers">
      <summary>
            If set, then the Key Point Visualizer UI will have the Key Points option available, and your code should respond to various keypoint actions.
            Ideally, there should be at least one and preferably three or more items to choose from.
            For 1st Person, there should be two or more, and for 3rd person, there should be three.
            If there is less than needed 2 (1stperson) or 3 (3rdperson), then this will limit how many Keypoints there can be selected in the UI.
            <remarks>This also implies that the UI has both 1st and 3rd person options, which further controls that is enabled</remarks></summary>
    </member>
    <member name="F:Bertec.SceneFeatures.Cognitive">
      <summary>
            If set, has a special panel of Cognitive Choices with sub-options/difficulties
            </summary>
    </member>
    <member name="T:Bertec.SceneProperty">
      <summary>
            SceneProperty items are list of things that the UI can set in the Scene.
            </summary>
    </member>
    <member name="T:Bertec.SceneEvent">
      <summary>
            SceneEvent items are list of things that can be triggered in either the UI or the Scene
            </summary>
    </member>
    <member name="F:Bertec.SceneEvent.IsTriggerableFromUI">
      <summary>
            If true, then the UI should display a button to trigger some event on the Unity side or otherwise connect it.
            </summary>
    </member>
    <member name="F:Bertec.SceneEvent.IsTriggerableFromScene">
      <summary>
            If true, then the scene will trigger the ui with this event. The UI should allow the scene to control some action.
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.OptionType.None">
      <summary>
            No option.
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.OptionType.Checkbox">
      <summary>
            Simple checkbox. Choices will be ignored.
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.OptionType.Choicelist">
      <summary>
            Could be a combo box or a set of radio buttons. Choices will be used to present the items.
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.OptionType.Range">
      <summary>
            Typically a slider. Choices are used to build the range.
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.OptionType.Text">
      <summary>
            Any value, UI shows an edit box. Choices will be ignored.
            </summary>
    </member>
    <member name="T:Bertec.SceneOption.RequirementType">
      <summary>
            RequirementType is used to tell the UI if the option needs to be set or not. It is up to the UI to handle this.
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.RequirementType.NotRequired">
      <summary>
            Value can be blank (default type, no requirement).
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.RequirementType.Required">
      <summary>
            Value cannot be blank, but can be default.
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.RequirementType.RequiredAlways">
      <summary>
            Value must be changed, even if the default is used (user must touch).
            </summary>
    </member>
    <member name="T:Bertec.SceneOption.Decimals">
      <summary>
            When calling SetRange with float values, use this to determine how many decimal points to show
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.Type">
      <summary>
            Used to determine which UI element to display.
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.Requirement">
      <summary>
            Optional. If set, then this option must have a valid value before the test can be started. Not used for the Title type.
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.Key">
      <summary>
            Required. The unique id that will be used to track the option and save/restore from database. Also used to send/return from the unity scene and pc UI.
            Can be the same value in different scenes, but must be unique within a scene.
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.Name">
      <summary>
            Optional. The display name that is shown on the UI display on the button/callout and the title box if any.
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.Description">
      <summary>
            Optional. Describes what the option is (can be used for the UI or other documentation).
            </summary>
    </member>
    <member name="F:Bertec.SceneOption.Grouping">
      <summary>
            Optional; defines the grouping section the option belongs to (used by UI to organize things).
            </summary>
    </member>
    <member name="P:Bertec.SceneOption.Group">
      <summary> Easy alias to allow setting a single top-level group.</summary>
    </member>
    <member name="P:Bertec.SceneOption.Subgroup">
      <summary> Easy alias to allow setting a the 2nd level sub group once the top level has been set.</summary>
    </member>
    <member name="M:Bertec.SceneOption.SetGroup(System.String[])">
      <summary> Easy function to set the group with a list of strings</summary>
    </member>
    <member name="F:Bertec.SceneOption.Choices">
      <summary>
            Valid for Type.Choicelist and Type.Range only. Array of choices that will be displayed for the user to see.
            Choices will be shown in the same order as they appear in the array.
            Not used for the Title type.
            </summary>
    </member>
    <member name="F:Bertec.KeyPointOption.Key">
      <summary>
            Required. The unique id that will be used to track the option and save/restore from database. Also used to send/return from the unity scene and pc UI.
            Can be the same value in different scenes, but must be unique within a scene.
            </summary>
    </member>
    <member name="F:Bertec.KeyPointOption.Name">
      <summary>
            Optional. The display name that is shown on the UI display on the button/callout and the title box if any.
            </summary>
    </member>
    <member name="F:Bertec.KeyPointOption.Description">
      <summary>
            Optional. Describes what the option is (can be used for the UI or other documentation).
            </summary>
    </member>
    <member name="F:Bertec.KeyPointOption.Choices">
      <summary>
            Array of choices that will be displayed for the user to see.
            Choices will be shown in the same order as they appear in the array.
            </summary>
    </member>
    <member name="F:Bertec.SceneInfo.ScenePath">
      <summary>
            Internal value that is used by the SceneManager to locate the scene to load. Not exposed to the UI.
            </summary>
      <remarks>
            The SceneListManager will populate this field based on the primary Key value. If your scene would prefer to set this itself,
            do so in the constructor.
            </remarks>
    </member>
    <member name="F:Bertec.SceneInfo.Key">
      <summary>
            Required. The unique id is used to find and display the scene (will be tied to an actual scene asset).
            <note>Typically this will be just the filename part of the scene path - ex: Foobar for "Assets/folder/Foobar.unity"</note></summary>
      <remarks>
            If more than one possible key value can be used to reference the scene, override the <see cref="P:Bertec.SceneInfo.AKA" /> property and return those as well.
            </remarks>
    </member>
    <member name="F:Bertec.SceneInfo.Name">
      <summary>
            Required. The name that is displayed in the UI.
            </summary>
    </member>
    <member name="F:Bertec.SceneInfo.Description">
      <summary>
            Optional; describes what the scene is (can be used for the UI).
            </summary>
    </member>
    <member name="F:Bertec.SceneInfo.Icon">
      <summary>
            Optional; a byte array of the icon image to display in the UI (typically png format).
            <note>If the scene does not provide this directly, the SceneListManager will attempt to find one in the Streaming Assets folder</note></summary>
    </member>
    <member name="F:Bertec.SceneInfo.Features">
      <summary>
            Optional; not used for most scenes but the UI can use to determine specific features.
            </summary>
    </member>
    <member name="F:Bertec.SceneInfo.Options">
      <summary>
            All the options and choices. Technically optional, but you'll want to have some.
            </summary>
    </member>
    <member name="F:Bertec.SceneInfo.Events">
      <summary>
            List of Events the scene and send or receive. The scene may trigger these and send to the UI, and the UI may also trigger these and send back
            </summary>
    </member>
    <member name="F:Bertec.SceneInfo.Properties">
      <summary>
            List of Properties the scene can understand (or send to the UI). Similar to options without any choices (may be removed later)
            </summary>
    </member>
    <member name="M:Bertec.SceneInfo.#ctor">
      <summary>
            The default constructor will take the Key, Name, and other items from the attribute tag, if set
            </summary>
    </member>
    <member name="M:Bertec.SceneInfo.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Bertec.SceneInfo" /> class. This is desrired constructor to use.
            </summary>
      <param name="key">The value to be used for the Key. This will be used to generate the ScenePath unless that is set explictly.</param>
      <param name="name">The value to be used for the Name.</param>
    </member>
    <member name="P:Bertec.SceneInfo.AKA">
      <summary>
            Returns a list of all the keys that can be used to identify this scene.
            By default this will just be the <see cref="F:Bertec.SceneInfo.Key" /> and <see cref="F:Bertec.SceneInfo.Name" /> values, but can be more.
            </summary>
      <remarks>
            Typically used when a possible "Scene" option references a historical value that has changed or can be mapped to another scene.
            </remarks>
    </member>
    <member name="P:Bertec.SceneInfo.IconPath">
      <summary>
            Tries to find the matching icon from the given key name. Used during the init/build phase to generate the optional icon
            </summary>
    </member>
    <member name="M:Bertec.SceneListManager.GetSceneInfoList(System.Boolean)">
      <summary>
            Retrieves a list of SceneInfo objects representing the scenes in the build settings. The build process uses this to generate the
            scene info json file, and the runtime manager uses this to get a list of scenes that can be loaded by key name or alias.
            </summary>
      <param name="resolvePaths">A boolean value indicating whether to resolve the scene paths. False for the build, true at runtime.</param>
      <returns>A list of SceneInfo objects.</returns>
    </member>
    <member name="M:Bertec.Utils.GetBoundingForGameObject(UnityEngine.GameObject,System.Boolean)">
      <summary>Helper method to calculate the bounds of a game object and its children</summary>
    </member>
    <member name="M:Bertec.Utils.GetBoundingForGameObject(UnityEngine.GameObject,UnityEngine.Bounds[])">
      <summary>
            Get the bounding box for the item
            </summary>
    </member>
    <member name="M:Bertec.Utils.GetBoundsForChildren(UnityEngine.GameObject,System.Boolean)">
      <summary>
            Get the bounding boxes for this item's children; does not include itself
            </summary>
    </member>
    <member name="M:Bertec.Utils.Coroutines.WaitForSeconds(System.Single,System.Boolean)">
      <summary>
            Waits for the specified amount of seconds, either in scaled time (just as Unity's UnityEngine.WaitForSeconds) or in unscaled time.
            </summary>
      <param name="seconds">Duration in seconds to wait before continuing.</param>
      <param name="unscaled">Should the wait time ignore UnityEngine.Time.timeScale?</param>
      <returns>An object representing the coroutine.</returns>
    </member>
    <member name="M:Bertec.Utils.Coroutines.WaitForSecondsRealtime(System.Single)">
      <summary>
            Waits for the specified amount of seconds in real time. Lighter replacement for UnityEngine.WaitForSecondsRealtime.
            </summary>
      <param name="seconds">The amount of seconds to wait for.</param>
    </member>
    <member name="M:Bertec.Utils.Coroutines.WaitForAsyncOperation(UnityEngine.AsyncOperation)">
      <summary>
            Waits until the specified UnityEngine.AsyncOperation is done.
            </summary>
      <param name="operation">The async operation to wait for.</param>
    </member>
    <member name="M:Bertec.Utils.Coroutines.Start(System.Collections.IEnumerator)">
      <summary>
            Starts a new coroutine.
            </summary>
      <param name="enumerator">The enumerator to execute.</param>
      <returns>The id of the coroutine.</returns>
    </member>
    <member name="M:Bertec.Utils.Coroutines.Start(System.Collections.IEnumerator,System.Int32)">
      <summary>
            Starts a new coroutine.
            </summary>
      <param name="enumerator">The enumerator to execute.</param>
      <param name="updateLoopId">Which update loop should the coroutine be part of?</param>
      <returns>The id of the coroutine.</returns>
    </member>
    <member name="M:Bertec.Utils.Coroutines.Stop(System.Int32)">
      <summary>
            Stops a running coroutine prematurely. This will stop any child coroutines as well.
            </summary>
      <param name="id">The id of the coroutine to stop.</param>
      <returns>True if the coroutine was found and stopped, otherwise false.</returns>
    </member>
    <member name="M:Bertec.Utils.Coroutines.StopAll">
      <summary>Stops all coroutines.</summary>
    </member>
    <member name="M:Bertec.Utils.Coroutines.IsRunning(System.Int32)">
      <summary>
            Checks whether a coroutine with the given ID is running. A paused coroutine is
            still considered running.
            </summary>
      <param name="id">The id of the coroutine to check.</param>
      <returns>True if running, otherwise false.</returns>
    </member>
    <member name="M:Bertec.Utils.Coroutines.SetPaused(System.Int32,System.Boolean)">
      <summary>
            Pauses or unpauses a coroutine.
            </summary>
      <param name="id">The id of the coroutine.</param>
      <param name="paused">True to pause, false to unpause.</param>
    </member>
    <member name="M:Bertec.Utils.Coroutines.IsPaused(System.Int32)">
      <summary>
            Checks whether a coroutine is currently paused either directly or because of
            a paused parent.
            </summary>
      <param name="id">Id of the coroutine.</param>
      <returns>True if paused or parent is paused, otherwise false.</returns>
    </member>
    <member name="M:Bertec.Utils.Coroutines.Pause(System.Int32)">
      <summary>
            Pauses a coroutine.
            </summary>
      <param name="id">Id of the coroutine to pause.</param>
    </member>
    <member name="M:Bertec.Utils.Coroutines.Unpause(System.Int32)">
      <summary>
            Unpauses a paused coroutine.
            </summary>
      <param name="id">Id of the coroutine to unpause.</param>
    </member>
    <member name="M:Bertec.VideoStreamer.Start">
      <summary>
            Starts listening for the stream start/stop commands to be issued. Called this from VideoStreamerContainer_Impl
            </summary>
      <returns>
      </returns>
    </member>
  </members>
</doc>